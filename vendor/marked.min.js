(function(){
  function escapeHtml(s){
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Very small markdown-ish parser with support for:
  // - fenced code blocks ``` ```
  // - headings (#)
  // - unordered lists (- or *)
  // - bold **bold** and *italic*
  // - inline code `code`
  // - blockquotes starting with >
  // - links [text](url)
  // - inline math $...$ and block math $$...$$ preserved as spans/divs with classes
  function parse(src){
    if(!src) return '';

    // Preserve fenced code blocks first (support optional language after the opening backticks)
    src = src.replace(/```(?:\s*([^\n]*))?\n?([\s\S]*?)```/g, function(_, lang, code){
      var cls = '';
      if (lang && lang.trim()) {
        // sanitize language token
        var l = lang.trim().split(/\s+/)[0].replace(/[^a-zA-Z0-9_\-+]/g,'');
        cls = ' class="language-' + l + '"';
      }
      return '<pre><code' + cls + '>' + escapeHtml(code) + '</code></pre>';
    });

    // Preserve block math $$...$$
    src = src.replace(/\$\$([\s\S]*?)\$\$/g, function(_, math){
      return '<div class="math-block">' + escapeHtml(math.trim()) + '</div>';
    });

    const lines = src.split(/\n/);
    const out = [];
    let inList = false;
    lines.forEach(function(raw){
      const line = raw.replace(/\t/g, '    ');
      if (!line.trim()) {
        if (inList) { out.push('</ul>'); inList = false; }
        out.push('');
        return;
      }

      // headings
      const h = line.match(/^(#{1,6})\s+(.*)$/);
      if (h) { if (inList) { out.push('</ul>'); inList = false; } out.push('<h'+h[1].length+'>' + formatInline(h[2]) + '</h'+h[1].length+'>'); return; }

      // blockquote
      const bq = line.match(/^>\s?(.*)$/);
      if (bq) { if (inList) { out.push('</ul>'); inList = false; } out.push('<blockquote>' + formatInline(bq[1]) + '</blockquote>'); return; }

      // unordered list
      const li = line.match(/^\s*[-\*]\s+(.*)$/);
      if (li) {
        if (!inList) { out.push('<ul>'); inList = true; }
        out.push('<li>' + formatInline(li[1]) + '</li>');
        return;
      }

      // paragraph
      if (inList) { out.push('</ul>'); inList = false; }
      out.push('<p>' + formatInline(line) + '</p>');
    });

    if (inList) out.push('</ul>');

    return out.join('');
  }

  function formatInline(text){
    if (!text) return '';
    // escape
    text = escapeHtml(text);
    // links
    text = text.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
    // bold **text**
    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    // italic *text* or _text_
    text = text.replace(/(^|[^\\])\*([^\*]+)\*(?!\*)/g, '$1<em>$2</em>');
    text = text.replace(/_(.*?)_/g, '<em>$1</em>');
    // inline code `code`
    text = text.replace(/`([^`]+)`/g, function(_, m){ return '<code>' + m + '</code>'; });
    // inline math $...$ (preserve content inside span)
    text = text.replace(/\$(\S(?:[\s\S]*?\S)?)\$/g, function(_, m){ return '<span class="math-inline">' + m + '</span>'; });
    return text;
  }

  window.marked = { parse: parse, setOptions: function(){ /* noop for compatibility */ } };
})();
